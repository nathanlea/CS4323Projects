Script started on Sun 06 Mar 2016 04:26:55 PM CST
bash-4.3$ whoami | name
No arguments, operating as filter
Userid    Name                          Home Dir
nathahl   LEA NATHAN H                  /home/nathahl 
Found 1 matches
bash-4.3$ ls -ltr
total 48
-rw-r--r-- 1 nathahl nathahl 29408 Mar  6 16:21 MemorySimulation.java
-rw-r--r-- 1 nathahl nathahl  1379 Mar  6 16:25 Main.java
-rw------- 1 nathahl nathahl  8150 Mar  6 16:25 MemorySimulation.class
-rw------- 1 nathahl nathahl  1288 Mar  6 16:25 Main.class
-rw------- 1 nathahl nathahl     0 Mar  6 16:26 typescript
bash-4.3$ javac *.java
bash-4.3$ ls -ltr
total 48
-rw-r--r-- 1 nathahl nathahl 29408 Mar  6 16:21 MemorySimulation.java
-rw-r--r-- 1 nathahl nathahl  1379 Mar  6 16:25 Main.java
-rw------- 1 nathahl nathahl     0 Mar  6 16:26 typescript
-rw------- 1 nathahl nathahl  8150 Mar  6 16:27 MemorySimulation.class
-rw------- 1 nathahl nathahl  1288 Mar  6 16:27 Main.class
bash-4.3$ pr -n Main.java MemorySimulation.java


2016-03-06 16:25                    Main.java                     Page 1


    1	public class Main {
    2	
    3	    public static void main(String[] args) {
    4	        /**
    5	         * method
    6	         * 0 - First Fit
    7	         * 1 - Best Fit - Current Best Hole
    8	         * 2 - Worst Fit - Current Worst Hole
    9	         * 3 - Best Best Fit - Best Hole Ever
   10	         * 4 - Worst Worst Fit - Worst Hole Ever
   11	         */
   12	       System.out.println("=============================================================== First Fit =============================================================");
   13	       new MemorySimulation(0).simulate();
   14	       System.out.println("\n============================================================== Best Fit ===============================================================");
   15	       new MemorySimulation(1).simulate();
   16	       System.out.println("\n============================================================== Worst Fit ==============================================================");
   17	       new MemorySimulation(2).simulate();
   18	       System.out.println("\n============================================================== Best Best Fit ==========================================================");
   19	       new MemorySimulation(3).simulate();
   20	       System.out.println("\n============================================================== Worst Worst Fit ========================================================");
   21	       new MemorySimulation(4).simulate();
   22	    }
   23	}








































2016-03-06 16:21              MemorySimulation.java               Page 1


    1	import java.security.SecureRandom;
    2	import java.util.PriorityQueue;
    3	import java.util.Queue;
    4	import java.util.Random;
    5	
    6	/**
    7	 * <h2>The class is a memory simulation to test and compare first fit/best fit/worst fit memory placement strategies</h2>
    8	 *
    9	 * <i>Developed by Nathan Lea on 2/8/2016 - 3/8/2016 for CS4303 Operating Systems</i>
   10	 */
   11	
   12	
   13	public class MemorySimulation {
   14	    private final int startingPID = 10000;
   15	
   16	    /**
   17	     * The main memory array for all of the jobs to go into
   18	     */
   19	    private int[] memory = new int[180];
   20	
   21	    /**
   22	     * Describes what the next id for the job will be,
   23	     * used to keep track of the many jobs going through the simulation
   24	     * this is used in the same way as a linux system where the PIDs
   25	     * increase by ever job
   26	     */
   27	    private int nextJobPID = startingPID;
   28	
   29	    /**
   30	     * The Secure Random Object used as the random number generator for the system
   31	     */
   32	    private SecureRandom r = new SecureRandom();
   33	
   34	    /**
   35	     * method
   36	     * 0 - First Fit
   37	     * 1 - Best Fit - Current Best Hole
   38	     * 2 - Worst Fit - Current Worst Hole
   39	     * 3 - Best Best Fit - Best Hole Ever
   40	     * 4 - Worst Worst Fit - Worst Hole Ever
   41	     */
   42	    private int method = 0;
   43	
   44	    /**
   45	     * used to in the memory placement to tell whether the placement rejected the job
   46	     */
   47	    private boolean notRejected = true;
   48	
   49	    /**
   50	     *  Count of the number of jobs completed between 1000 and 4000
   51	     */
   52	    private int jobsInRange = 0;
   53	
   54	    /**
   55	     * Track data about completed jobs
   56	     */







2016-03-06 16:21              MemorySimulation.java               Page 2


   57	    private double turnAroundTime = 0, waitingTime = 0, processingTime = 0;
   58	
   59	    /**
   60	     * Counter to track the number of VTU's that the CPU has nothing to do
   61	     */
   62	    private int idleTime = 0;
   63	
   64	    /**
   65	     * Ready Queue to track jobs that have been inserted into memory and are waiting to be completed by the CPU
   66	     */
   67	    private Queue<Integer> readyQueue = new PriorityQueue<Integer>();
   68	
   69	    /**
   70	     * The current PID of the job that the simulation is working on
   71	     */
   72	    private int currentJob = 9001;
   73	
   74	    /**
   75	     * The queue of the rejected jobs that were to big to fit into memory
   76	     */
   77	    private Queue<Integer> rejectedJobs = new PriorityQueue<Integer>();
   78	
   79	    /**
   80	     * @param method {@link MemorySimulation#method}
   81	     */
   82	    public MemorySimulation(int method ) {
   83	        //Starts the memory management
   84	        this.method = method;
   85	
   86	        System.out.println("VTU\t|\tTotal Fragmented KBs\t|\tStorage Utilization (Used/Total)\t|\tAverage Hole Size\t|Rejected Jobs");
   87	    }
   88	
   89	    /**
   90	     * Starts the simulation of Memory
   91	     */
   92	    public void simulate( ) {
   93	        boolean successfullyRemovedFromMemory = true;
   94	
   95	        int nextStatOutput = 1000;
   96	        int[] jobAtDoor = new int[4];
   97	
   98	        int firstJobArrives = getNextJobArrival(), nextJobArrival = firstJobArrives; //Get first job arrival Time
   99	
  100	        /**
  101	         * Event driven Memory Simulation Loop
  102	         */
  103	        for( int VTU = firstJobArrives; VTU < 5000; ) {
  104	
  105	            /***************************************************
  106	             * Handle periodic Outputs
  107	             *
  108	             * NOTE: Since this is an event driven simulation
  109	             * this output will never be at 100's exactly
  110	             **************************************************/
  111	            if(VTU > nextStatOutput) {
  112	                outputAt100(nextStatOutput);







2016-03-06 16:21              MemorySimulation.java               Page 3


  113	                if(nextStatOutput%1000==0) outputAt1000();
  114	                System.out.println();
  115	                if(nextStatOutput==4000) {
  116	                    /*************************************
  117	                     * Finished the Area of Concern
  118	                     * Output some information
  119	                     ************************************/
  120	                    System.out.println("_______________________________________________________________________________________________________________________________________");
  121	                    System.out.println();
  122	                    endingOutput();
  123	                    nextStatOutput = 9999; //Stop outputting
  124	                }
  125	                nextStatOutput+=100;
  126	            }
  127	
  128	            /*********************
  129	             * Initial First Case
  130	             ********************/
  131	            if( firstJobArrives == VTU ) {
  132	                nextJobPID++;
  133	                int[] job = initializer(nextJobPID, VTU); //Generate New Job
  134	                memoryManager(job, true); //Place job in memory
  135	                readyQueue.add(job[0]); nextJobPID++; //add PID to readyQueue to get activated
  136	            }
  137	
  138	            /***********************
  139	             * CPU
  140	             **********************/
  141	            if( currentJob != 9001 ) {
  142	                successfullyRemovedFromMemory = CPU(VTU);
  143	            }
  144	
  145	            /***********************************
  146	             * There is no next job, move VTU to
  147	             * next event of loading a new job
  148	             **********************************/
  149	            if(!successfullyRemovedFromMemory && readyQueue.isEmpty()) {
  150	                idleTime += (nextJobArrival - VTU);
  151	                VTU = nextJobArrival;
  152	            }
  153	
  154	            /**********************************
  155	             * Loader
  156	             *********************************/
  157	            while( nextJobArrival <= VTU && memoryManager(jobAtDoor, true) ) {
  158	
  159	                if( jobAtDoor[0] != 0 && notRejected ) {
  160	                    readyQueue.add(jobAtDoor[0]);
  161	                    nextJobPID++;
  162	                }
  163	                jobAtDoor = initializer(nextJobPID, VTU);
  164	                nextJobArrival += getNextJobArrival();
  165	            }
  166	
  167	            /*******************************
  168	             * Dispatcher







2016-03-06 16:21              MemorySimulation.java               Page 4


  169	             ******************************/
  170	            if( readyQueue.size() != 0 ) {
  171	                currentJob = readyQueue.poll();
  172	                VTU += getDurationOfJob(currentJob);
  173	            }
  174	        }
  175	        /*************************************
  176	         * Final print of rejected jobs
  177	         ************************************/
  178	        System.out.println("Rejected Jobs @ 5000: " + rejectedJobs.size());
  179	    }
  180	
  181	    /**
  182	     * Used to get a random number to add to the VTU,
  183	     * to get the next job arrival
  184	     *
  185	     * @return Random number 0-10
  186	     * @see Random
  187	     */
  188	    private int getNextJobArrival( ) {
  189	        return r.nextInt(10)+1;
  190	    }
  191	
  192	    /**
  193	     * Method to simulation a CPU completed work on a task and calling
  194	     * the {@link MemorySimulation#memoryManager(int[], boolean)} to remove
  195	     * the job from {@link MemorySimulation#memory}
  196	     *
  197	     * @param VTU Current Virtual Time Unit of the simulation
  198	     * @return Success of removing the current job from memory
  199	     */
  200	    private boolean CPU(int VTU) {
  201	        int durationOfJob = getDurationOfJob(currentJob);  //Get the duration of the job that is being removed
  202	        int jobTime = getJobTime(currentJob);              //Get the time that the job was inserted in memory
  203	
  204	        /************************************************************
  205	         * If successfullyRemovedFromMemory is
  206	         * true the job was found in memory and removed
  207	         *
  208	         * If not there was an error but this should
  209	         * never happen merely protection to not through an error
  210	         * like in the event of the CPU is stalling
  211	         * or waiting on a new job to come
  212	         ************************************************************/
  213	
  214	        boolean successfullyRemovedFromMemory = memoryManager(new int[]{currentJob,0,0,0}, false); //Remove from memory
  215	
  216	        /************************************************************
  217	         * If we are in the simulation period get some data from the removed job
  218	         ***********************************************************/
  219	
  220	        if( successfullyRemovedFromMemory && ( VTU>=1000 && VTU<=4000 ) ) {
  221	            waitingTime += VTU - jobTime;
  222	            processingTime += durationOfJob;
  223	            turnAroundTime += ( VTU - jobTime ) + durationOfJob;
  224	            jobsInRange++;







2016-03-06 16:21              MemorySimulation.java               Page 5


  225	        }
  226	        return successfullyRemovedFromMemory;
  227	    }
  228	
  229	    /**
  230	     * Calls the {@link Random} to generate the size, duration of the
  231	     * new job to the system
  232	     *
  233	     * @param nextJobPID the next pid to set to the generated job
  234	     * @param VTU Current Virtual Time Unit of the simulation
  235	     * @return An int array with the information about a job
  236	     */
  237	    public int[] initializer(int nextJobPID, int VTU) {
  238	        int size = (r.nextInt(26) + 5) * 10;
  239	        int duration = ((r.nextInt(56)) + 5);
  240	        duration = 5 * (Math.round(duration / 5));
  241	        return new int[]{nextJobPID, size, duration, VTU};
  242	    }
  243	
  244	    /**
  245	     * Places or removes a job into memory
  246	     * If placing looks at method and calls the proper placement algorithm
  247	     * If removed calls the dispatched to free memory block
  248	     *
  249	     * @param job The array of information about the job to be placed or removed in memory
  250	     * @param place True is placing a job in memory, False if removing job from memory
  251	     * @return success of the function, either placing or removing
  252	     * @see MemorySimulation#placeFirstFit(int, int, int, int)
  253	     * @see MemorySimulation#placeBestFit(int, int, int, int)
  254	     * @see MemorySimulation#placeWorstFit(int, int, int, int)
  255	     * @see MemorySimulation#departure(int)
  256	     */
  257	    private boolean memoryManager(int[] job, boolean place) {
  258	        int PID      = job[0];
  259	        int size     = job[1];
  260	        int duration = job[2];
  261	        int genTime  = job[3];
  262	
  263	        if( PID == 0 ) return true; //The is a catch for the first time through the VTU loop
  264	
  265	        /************************************************************
  266	         * If we are placing use the appropriate memory algorithm
  267	         ***********************************************************/
  268	        if( place ) {
  269	            if (method == 0) {
  270	                return placeFirstFit(PID, size, duration, genTime);
  271	            } else if (method == 1 || method == 3) {
  272	                return placeBestFit(PID, size, duration, genTime);
  273	            } else if (method == 2 || method == 4) {
  274	                return placeWorstFit(PID, size, duration, genTime);
  275	            } else { //Error Case, reject Job
  276	                rejectedJobs.add(PID);
  277	                notRejected = false;
  278	                return true;
  279	            }
  280	        } else {







2016-03-06 16:21              MemorySimulation.java               Page 6


  281	            /************************************************************
  282	             * If we are removing the job, call the departure with the PID
  283	             ***********************************************************/
  284	            return departure(PID);
  285	        }
  286	    }
  287	
  288	    /**
  289	     * The memory placement algorithm that find the first hole and places
  290	     * the job in the first hole big enough to hold the job
  291	     *
  292	     * @param PID The Job Identifier
  293	     * @param size The size of the Job
  294	     * @param duration The duration that the job takes to complete
  295	     * @param genTime What time did the job get put in memory
  296	     * @return True, if job was placed False, if job either was not placed.
  297	     * The global notRejected tells the program if the job was reject or not
  298	     */
  299	    private boolean placeFirstFit(int PID, int size, int duration, int genTime) {
  300	        for (int i = 0; i < memory.length - 1; i++) {
  301	            if (memory[i] == memory[i + 1] || memory[i] == 0) {
  302	                /**
  303	                 * There is a similar piece of memory here, check if it is a hole
  304	                 */
  305	                if (memory[i] < 0 || memory[i] == 0) {
  306	                    /**
  307	                     * There hole here, count the size of the hole
  308	                     */
  309	                    int sizeOfHole = 1;
  310	                    int j = i;
  311	                    while (memory.length > j + 1 && (memory[j] == memory[j + 1] || memory[j] == 0)) {
  312	                        sizeOfHole++;
  313	                        j++;
  314	                    }
  315	                    if ((size / 10) <= sizeOfHole) {
  316	                        /**
  317	                         * The job can fit!!
  318	                         * Place the job in memory
  319	                         */
  320	                        memory[i] = PID;
  321	                        memory[i + 1] = size;
  322	                        memory[i + 2] = duration;
  323	                        memory[i + 3] = genTime;
  324	                        memory[i + 4] = PID;
  325	                        for (int m = i + 5; m < (size / 10) + (i); m++) {
  326	                            memory[m] = PID;
  327	                        }
  328	                        notRejected = true;
  329	                        return true;
  330	                    } else {
  331	                        /**
  332	                         * The hole isn't big enough, try next hole
  333	                         */
  334	                    }
  335	                }
  336	            }







2016-03-06 16:21              MemorySimulation.java               Page 7


  337	        }
  338	
  339	        /**
  340	         * No current hole, check if there will ever be a hole
  341	         */
  342	        for( int i = 0; i< memory.length - 1; i++) {
  343	            if (memory[i] == memory[i + 1] || memory[i] == 0) {
  344	                /**
  345	                 * Similar piece of memory, count the size
  346	                 */
  347	                int sizeOfHole = 1;
  348	                int j = i;
  349	                while (memory.length > j + 1 && (memory[j] == memory[j + 1])) {
  350	                    sizeOfHole++;
  351	                    j++;
  352	                }
  353	                /**
  354	                 * If the hole is currently occupied, add the memory header to the size of the spot
  355	                 */
  356	                if( memory[i] > 0 ) { sizeOfHole+=4;  }
  357	                if( ( size / 10 ) <= sizeOfHole ) {
  358	                    /**
  359	                     * The job will eventually fit in memory, wait until that job completes
  360	                     */
  361	                    notRejected = true;
  362	                    return false;
  363	                }
  364	            }
  365	        }
  366	        /**
  367	         * No possible place for it to go
  368	         * Reject the job, and return true to get next job
  369	         */
  370	        rejectedJobs.add(PID);
  371	        notRejected = false;
  372	        return true;
  373	    }
  374	
  375	    /**
  376	     * The memory strategy that find the best current hole and places the job in that hole
  377	     * that creates the smallest left over hole
  378	     *
  379	     * If method == 3 then this method is also used for best best fit, which places a job in the best
  380	     * possible hole that will ever be. This is used to expand on and see best fit blow up to create a
  381	     * bigger difference
  382	     *
  383	     * @param PID The Job Identifier
  384	     * @param size The size of the Job
  385	     * @param duration The duration that the job takes to complete
  386	     * @param genTime What time did the job get put in memory
  387	     * @return True, if job was placed False, if job either was not placed.
  388	     * The global notRejected tells the program if the job was reject or not
  389	     */
  390	    private boolean placeBestFit(int PID, int size, int duration, int genTime) {
  391	        int bestSize = 999;
  392	        int bestSizeLocation = 0;







2016-03-06 16:21              MemorySimulation.java               Page 8


  393	        boolean bestLocationHole = true;
  394	        boolean currentHole;
  395	
  396	        for (int i = 0; i < memory.length - 1; i++) {
  397	            if (memory[i] == memory[i + 1] || memory[i] == 0) {
  398	                /**
  399	                 * There is a similar piece of memory here, count the size
  400	                 */
  401	                int sizeOfHole = 1;
  402	                int j = i;
  403	                while (memory.length > j + 1 && (memory[j] == memory[j + 1] || memory[j] == 0)) {
  404	                    sizeOfHole++;
  405	                    j++;
  406	                }
  407	                /**
  408	                 * We Found a hole with a size that could fit the job
  409	                 * Is it the best sized hole that we have found
  410	                 *
  411	                 * Only if it is best best to we want to look at occupied memory
  412	                 */
  413	                if( method == 1 && memory[i] > 0 ) { i=j; continue; } //If it is best and not current hole, ignore
  414	
  415	                if( memory[i] > 0 ) {
  416	                    sizeOfHole+=4;
  417	                    currentHole = false;
  418	                } else {
  419	                    currentHole = true;
  420	                }
  421	
  422	                /**
  423	                 * Check if it is the best hole so far, if so
  424	                 * update the location and size of the best hole
  425	                 */
  426	                if ((size / 10) <= sizeOfHole) {
  427	                    int extraRoom = sizeOfHole - (size / 10);
  428	                    int bestSoFarExtraRoom = bestSize - (size / 10);
  429	
  430	                    if (extraRoom < bestSoFarExtraRoom) {
  431	                        bestSize = sizeOfHole;
  432	                        bestSizeLocation = i;
  433	                        bestLocationHole = currentHole;
  434	                    }
  435	                }
  436	                i=j;
  437	            }
  438	        }
  439	        if( bestLocationHole && bestSize != 999 ) {
  440	            /**
  441	             * Best hole found, place job
  442	             */
  443	            memory[bestSizeLocation] = PID;
  444	            memory[bestSizeLocation + 1] = size;
  445	            memory[bestSizeLocation + 2] = duration;
  446	            memory[bestSizeLocation + 3] = genTime;
  447	            memory[bestSizeLocation + 4] = PID;
  448	            for (int m = bestSizeLocation + 5; m < (size / 10) + (bestSizeLocation); m++) {







2016-03-06 16:21              MemorySimulation.java               Page 9


  449	                memory[m] = PID;
  450	            }
  451	            notRejected = true;
  452	            return true;
  453	        } else if ( !bestLocationHole ) {
  454	            /**
  455	             * The best possible hole is not yet free
  456	             * Wait until free
  457	             */
  458	            notRejected = true;
  459	            return false;
  460	        } else if ( bestSize == 999 ) {
  461	            /**
  462	             * A hole was not found that could fit job.
  463	             * Check if it will ever fit
  464	             * If not reject
  465	             */
  466	            for( int i = 0; i < memory.length - 1; i++) {
  467	                if (memory[i] == memory[i + 1] || memory[i] == 0) {
  468	                    /**
  469	                     * Count the memory hole, and see if it is big enough
  470	                     */
  471	                    int sizeOfHole = 1;
  472	                    int j = i;
  473	                    while (memory.length > j + 1 && (memory[j] == memory[j + 1])) {
  474	                        sizeOfHole++;
  475	                        j++;
  476	                    }
  477	                    if( memory[i] > 0 ) { sizeOfHole+=4;  }
  478	                    if( ( size / 10 ) <= sizeOfHole ) {
  479	                        /**
  480	                         * The job will eventually fit
  481	                         */
  482	                        notRejected = true;
  483	                        return false;
  484	                    }
  485	                }
  486	            }
  487	            /**
  488	             * Unable to fit into memory
  489	             * Reject job!
  490	             */
  491	            rejectedJobs.add(PID);
  492	            notRejected = false;
  493	            return true;
  494	        } else {
  495	            /**
  496	             * No possible place for it to go
  497	             * Reject the job, and return true to get next job
  498	             */
  499	            rejectedJobs.add(PID);
  500	            notRejected = false;
  501	            return true;
  502	        }
  503	    }
  504	







2016-03-06 16:21              MemorySimulation.java              Page 10


  505	    /**
  506	     * The memory strategy that find the worst current hole and places the job in that hole
  507	     * that creates the largest left over hole
  508	     *
  509	     * If method == 4 then this method is also used for worst worst fit, which places a job in the worst
  510	     * possible hole that will ever be. This is used to expand on and see worst fit blow up to create a
  511	     * bigger difference
  512	     *
  513	     * @param PID The Job Identifier
  514	     * @param size The size of the Job
  515	     * @param duration The duration that the job takes to complete
  516	     * @param genTime What time did the job get put in memory
  517	     * @return True, if job was placed False, if job either was not placed.
  518	     * The global notRejected tells the program if the job was reject or not
  519	     */
  520	    private boolean placeWorstFit(int PID, int size, int duration, int genTime) {
  521	        int worstSize = 0;
  522	        int worstSizeLocation = 0;
  523	        boolean worstLocationHole = true;
  524	        boolean currentHole;
  525	
  526	        for (int i = 0; i < memory.length - 1; i++) {
  527	            if (memory[i] == memory[i + 1] || memory[i] == 0) {
  528	                /**
  529	                 * There is a similar piece of memory here, count the size
  530	                 */
  531	                int sizeOfHole = 1;
  532	                int j = i;
  533	                while (memory.length > j + 1 && (memory[j] == memory[j + 1] || memory[j] == 0)) {
  534	                    sizeOfHole++;
  535	                    j++;
  536	                }
  537	                /**
  538	                 * We Found a hole with a size that could fit the job
  539	                 * Is it the worst sized hole that we have found
  540	                 *
  541	                 * Only if it is worst worst to we want to look at occupied memory
  542	                 */
  543	                if( method == 2 && memory[i] > 0 ) { i=j; continue; }
  544	
  545	                if( memory[i] > 0 ) {
  546	                    sizeOfHole+=4;
  547	                    currentHole = false;
  548	                } else { currentHole = true; }
  549	
  550	                /**
  551	                 * Check if it is the worst hole so far, if so
  552	                 * update the location and size of the worst hole
  553	                 */
  554	                if ((size / 10) <= sizeOfHole) {
  555	                    int extraRoom = sizeOfHole - (size / 10);
  556	                    int worstSoFarExtraRoom = worstSize - (size / 10);
  557	
  558	                    if (extraRoom > worstSoFarExtraRoom) {
  559	                        worstSize = sizeOfHole;
  560	                        worstSizeLocation = i;







2016-03-06 16:21              MemorySimulation.java              Page 11


  561	                        worstLocationHole = currentHole;
  562	                    }
  563	                }
  564	                i=j;
  565	            }
  566	        }
  567	        if( worstLocationHole && worstSize != 0 ) {
  568	            /**
  569	             * Worst hole found, place job
  570	             */
  571	            memory[worstSizeLocation] = PID;
  572	            memory[worstSizeLocation + 1] = size;
  573	            memory[worstSizeLocation + 2] = duration;
  574	            memory[worstSizeLocation + 3] = genTime;
  575	            memory[worstSizeLocation + 4] = PID;
  576	
  577	            for (int m = worstSizeLocation + 5; m < (size / 10) + (worstSizeLocation); m++) {
  578	                memory[m] = PID;
  579	            }
  580	            notRejected = true;
  581	            return true;
  582	        } else if ( !worstLocationHole ) {
  583	            /**
  584	             * The worst possible hole is not yet free
  585	             * Wait until free
  586	             */
  587	            notRejected = true;
  588	            return false;
  589	        } else if ( worstSize == 0 ) {
  590	            /**
  591	             * A hole was not found that could fit job.
  592	             * Check if it will ever fit
  593	             * If not reject
  594	             */
  595	            for (int i = 0; i < memory.length - 1; i++) {
  596	                if (memory[i] == memory[i + 1] || memory[i] == 0) {
  597	                    /**
  598	                     * Will it fit! Somewhere
  599	                     */
  600	                    int sizeOfHole = 1;
  601	                    int j = i;
  602	                    while (memory.length > j + 1 && (memory[j] == memory[j + 1])) {
  603	                        sizeOfHole++;
  604	                        j++;
  605	                    }
  606	                    if (memory[i] > 0) {
  607	                        sizeOfHole += 4;
  608	                    }
  609	                    if ((size / 10) <= sizeOfHole) {
  610	                        /**
  611	                         * it will eventually fit
  612	                         */
  613	                        notRejected = true;
  614	                        return false;
  615	                    }
  616	                }







2016-03-06 16:21              MemorySimulation.java              Page 12


  617	            }
  618	            /**
  619	             * No possible place for it to go
  620	             * Reject the job, and return true to get next job
  621	             */
  622	            rejectedJobs.add(PID);
  623	            notRejected = false;
  624	            return true;
  625	        } else {
  626	            /**
  627	             * Not ever going to fit
  628	             * Reject the job
  629	             */
  630	            rejectedJobs.add(PID);
  631	            notRejected = false;
  632	            return true;
  633	        }
  634	    }
  635	
  636	    /**
  637	     * Frees memory block occupied with the given PID
  638	     *
  639	     * @param PID The PID of the job looking to be freed from memory
  640	     * @return True if memory freeing was successful, False if job was not found in memory
  641	     */
  642	    private boolean departure(int PID) {
  643	        for(int i = 0; i < memory.length ; i++) {
  644	            if(memory[i] ==  PID) {
  645	                int size = memory[i+1];
  646	                for( int j = i; j < ( size / 10) + i; j++ ) {
  647	                    memory[j] = -1 * PID;
  648	                }
  649	                return true;
  650	            }
  651	        }
  652	        return false;
  653	    }
  654	
  655	    /**
  656	     * Searches through memory and finds the memory block with
  657	     * the given PID and return the duration of the job
  658	     *
  659	     * @param PID PID of job to find the duration of
  660	     * @return the duration of the job with the given PID
  661	     */
  662	    private int getDurationOfJob(int PID){
  663	        //Linear Search
  664	        for( int i = 0; i < memory.length; i++) {
  665	            if( memory[i] == PID ) {
  666	                return (memory[i+2]);
  667	            }
  668	        }
  669	        return -1;
  670	    }
  671	
  672	    /**







2016-03-06 16:21              MemorySimulation.java              Page 13


  673	     * Searches through memory and finds the memory block with
  674	     * the given PID and return the duration of the job
  675	     *
  676	     * @param PID PID of job to find the time of
  677	     * @return the time of the job with the given PID
  678	     */
  679	    private int getJobTime(int PID){
  680	        //Linear Search
  681	        for( int i = 0; i < memory.length; i++) {
  682	            if( memory[i] == PID ) {
  683	                return (memory[i+3]);
  684	            }
  685	        }
  686	        return -1;
  687	    }
  688	
  689	    /**
  690	     * Loops through all of memory and averages the current holes
  691	     *
  692	     * @return the Average Size of the Holes in memory
  693	     */
  694	    private String averageHoleSize() {
  695	        int total = 0;
  696	        int count = 0;
  697	        for(int i = 0; i < memory.length - 1; i++) {
  698	            if( memory[i] == memory[i+1] || memory[i] == 0 ) {
  699	                if (memory[i] < 0 || memory[i] == 0) {
  700	                    int sizeOfHole = 1;
  701	                    int j = i;
  702	                    while (memory.length > j + 1 && (memory[j] == memory[j + 1] || memory[j] == 0)) {
  703	                        sizeOfHole++;
  704	                        j++;
  705	                    }
  706	                    i=j;
  707	                    total+=sizeOfHole;
  708	                    count++;
  709	                }
  710	            }
  711	        }
  712	        total*=10;
  713	        return String.format("%2.2f",(float) ((total*1.0)/(count*1.0)));
  714	    }
  715	
  716	    /**
  717	     * Loops through all of memory and adds the holes less than 5 blocks
  718	     *
  719	     * @return The number of blocks in hole less than 5, unusable memory
  720	     */
  721	    private float totalFragmentBytes() {
  722	        int total = 0;
  723	        for(int i = 0; i < memory.length - 1; i++) {
  724	            if( memory[i] == memory[i+1] || memory[i] == 0 ) {
  725	                if (memory[i] < 0 || memory[i] == 0) {
  726	                    int sizeOfHole = 1;
  727	                    int j = i;
  728	                    while (memory.length > j + 1 && ((memory[j] == memory[j + 1]) || memory[j] == 0)) {







2016-03-06 16:21              MemorySimulation.java              Page 14


  729	                        sizeOfHole++;
  730	                        j++;
  731	                    }
  732	                    if(sizeOfHole < 5)
  733	                        total+=sizeOfHole;
  734	                    i=j;
  735	                }
  736	            }
  737	        }
  738	        return total*10;
  739	    }
  740	
  741	    /**
  742	     * Calculates the total used memory and dives that by the total memory
  743	     *
  744	     * @return Used memory / total Memory
  745	     */
  746	    private String storageUtilization() {
  747	        float total = 0;
  748	        for(int m : memory) {
  749	            if(m > 0) {
  750	                total++;
  751	            }
  752	        }
  753	        return String.format("%2.2f",(float) ((total/180.0) * 100.0));
  754	    }
  755	
  756	    /**
  757	     * Output data about the simulation that just finished
  758	     * <ul>
  759	     * <li>Completed Jobs</li>
  760	     * <li>Waiting Jobs</li>
  761	     * <li>Rejected Jobs</li>
  762	     * <li>Turnaround Time</li>
  763	     * <li>Waiting Time</li>
  764	     * <li>Processing Time</li>
  765	     * <li>Idle Time</li> </ul>
  766	     */
  767	    private void endingOutput( ) {
  768	        waitingTime    = waitingTime    / (jobsInRange);
  769	        turnAroundTime = turnAroundTime / (jobsInRange);
  770	        processingTime = processingTime / (jobsInRange);
  771	        System.out.println("Performance Measurement:");
  772	        System.out.println("Turnaround Time\t" + String.format("%2.2f",turnAroundTime));
  773	        System.out.println("Waiting Time\t" + String.format("%2.2f",waitingTime));
  774	        System.out.println("Processing Time\t" + String.format("%2.2f",processingTime));
  775	        System.out.println("Completed Jobs\t" + (currentJob - 10000));
  776	    }
  777	
  778	    /**
  779	     * Outputs
  780	     * <ul>
  781	     * <li>VTU</li>
  782	     * <li>Completed Jobs</li>
  783	     * <li>Rejects Jobs</li>
  784	     * <li>Average Hole</li>







2016-03-06 16:21              MemorySimulation.java              Page 15


  785	     * <li>Total Fragmented Bytes</li>
  786	     * <li>Storage Utilization</li></ul>
  787	     *
  788	     */
  789	    private void outputAt100( int VTU ) {
  790	        System.out.print(VTU + "\t|\t\t" + totalFragmentBytes()+"\t\t|\t\t\t"+storageUtilization()+"\t\t\t|\t\t"+averageHoleSize()+"\t\t|");
  791	    }
  792	
  793	    /**
  794	     * Outputs the number of current Rejected jobs
  795	     */
  796	    private void outputAt1000( ) {
  797	        System.out.print("\t" + rejectedJobs.size());
  798	    }
  799	
  800	    /**
  801	     * Prints a memory dump of the memory array
  802	     * Used for debug purposes
  803	     */
  804	    private void memoryDump( ) {
  805	        for(int i = 0; i < 180; i++) {
  806	            System.out.print(memory[i]+ " || ");
  807	        }
  808	        System.out.println();
  809	    }
  810	}



































bash-4.3$ java Main
=============================================================== First Fit =============================================================
VTU	|	Total Fragmented KBs	|	Storage Utilization (Used/Total)	|	Average Hole Size	|Rejected Jobs
1000	|		190.0		|			35.56			|		55.00		|	12
1100	|		220.0		|			36.67			|		54.00		|
1200	|		240.0		|			33.33			|		51.82		|
1300	|		240.0		|			42.22			|		46.50		|
1400	|		270.0		|			25.56			|		51.25		|
1500	|		270.0		|			40.56			|		47.00		|
1600	|		270.0		|			36.67			|		47.62		|
1700	|		270.0		|			45.56			|		45.56		|
1800	|		270.0		|			33.89			|		49.05		|
1900	|		290.0		|			58.89			|		37.33		|
2000	|		290.0		|			47.78			|		42.22		|	107
2100	|		290.0		|			48.33			|		41.67		|
2200	|		290.0		|			45.00			|		42.11		|
2300	|		290.0		|			35.56			|		44.09		|
2400	|		290.0		|			35.56			|		45.71		|
2500	|		290.0		|			41.67			|		42.50		|
2600	|		290.0		|			34.44			|		44.09		|
2700	|		290.0		|			37.78			|		42.86		|
2800	|		290.0		|			24.44			|		47.50		|
2900	|		290.0		|			7.78			|		51.43		|
3000	|		310.0		|			41.67			|		41.50		|	251
3100	|		310.0		|			32.78			|		44.55		|
3200	|		310.0		|			23.33			|		46.00		|
3300	|		310.0		|			16.11			|		47.41		|
3400	|		310.0		|			7.78			|		49.31		|
3500	|		310.0		|			26.67			|		44.17		|
3600	|		310.0		|			17.22			|		45.56		|
3700	|		310.0		|			7.78			|		48.28		|
3800	|		310.0		|			29.44			|		43.91		|
3900	|		310.0		|			20.00			|		45.38		|
4000	|		310.0		|			7.78			|		48.28		|	362
_______________________________________________________________________________________________________________________________________

Performance Measurement:
Turnaround Time	285.69
Waiting Time	255.94
Processing Time	29.75
Completed Jobs	138
Rejected Jobs @ 5000: 573

============================================================== Best Fit ===============================================================
VTU	|	Total Fragmented KBs	|	Storage Utilization (Used/Total)	|	Average Hole Size	|Rejected Jobs
1000	|		360.0		|			36.67			|		59.44		|	17
1100	|		380.0		|			31.11			|		55.71		|
1200	|		380.0		|			28.89			|		55.00		|
1300	|		490.0		|			40.00			|		45.45		|
1400	|		490.0		|			26.11			|		50.00		|
1500	|		490.0		|			8.33			|		56.07		|
1600	|		510.0		|			50.56			|		33.91		|
1700	|		610.0		|			48.33			|		32.80		|
1800	|		610.0		|			41.67			|		34.81		|
1900	|		650.0		|			35.56			|		35.86		|
2000	|		650.0		|			32.22			|		36.67		|	55
2100	|		650.0		|			28.89			|		37.42		|
2200	|		690.0		|			38.89			|		33.79		|
2300	|		690.0		|			37.78			|		33.79		|
2400	|		690.0		|			40.00			|		33.21		|
2500	|		690.0		|			34.44			|		34.33		|
2600	|		690.0		|			23.33			|		37.27		|
2700	|		690.0		|			24.44			|		37.81		|
2800	|		730.0		|			42.78			|		31.07		|
2900	|		730.0		|			33.33			|		33.55		|
3000	|		730.0		|			39.44			|		31.72		|	203
3100	|		730.0		|			39.44			|		31.72		|
3200	|		730.0		|			27.22			|		34.55		|
3300	|		730.0		|			14.44			|		36.76		|
3400	|		730.0		|			29.44			|		33.03		|
3500	|		730.0		|			35.00			|		31.94		|
3600	|		730.0		|			21.67			|		35.14		|
3700	|		730.0		|			25.00			|		34.12		|
3800	|		730.0		|			25.56			|		33.82		|
3900	|		730.0		|			18.33			|		35.56		|
4000	|		730.0		|			19.44			|		36.00		|	413
_______________________________________________________________________________________________________________________________________

Performance Measurement:
Turnaround Time	280.00
Waiting Time	249.90
Processing Time	30.10
Completed Jobs	136
Rejected Jobs @ 5000: 586

============================================================== Worst Fit ==============================================================
VTU	|	Total Fragmented KBs	|	Storage Utilization (Used/Total)	|	Average Hole Size	|Rejected Jobs
1000	|		170.0		|			35.56			|		51.36		|	55
1100	|		190.0		|			21.11			|		53.46		|
1200	|		210.0		|			24.44			|		50.38		|
1300	|		250.0		|			22.78			|		47.86		|
1400	|		250.0		|			11.11			|		50.00		|
1500	|		320.0		|			18.89			|		44.84		|
1600	|		320.0		|			12.78			|		45.45		|
1700	|		360.0		|			25.00			|		40.00		|
1800	|		380.0		|			20.00			|		40.00		|
1900	|		380.0		|			13.89			|		40.86		|
2000	|		380.0		|			13.89			|		40.86		|	171
2100	|		380.0		|			14.44			|		40.57		|
2200	|		380.0		|			13.89			|		40.57		|
2300	|		380.0		|			13.89			|		40.29		|
2400	|		380.0		|			16.67			|		39.12		|
2500	|		380.0		|			26.11			|		36.45		|
2600	|		380.0		|			25.56			|		36.45		|
2700	|		380.0		|			22.78			|		36.88		|
2800	|		380.0		|			22.22			|		36.88		|
2900	|		380.0		|			13.33			|		38.29		|
3000	|		380.0		|			7.78			|		38.92		|	410
3100	|		380.0		|			15.00			|		37.65		|
3200	|		380.0		|			3.33			|		39.21		|
3300	|		380.0		|			0.00			|		39.74		|
3400	|		380.0		|			3.33			|		38.95		|
3500	|		380.0		|			0.00			|		39.49		|
3600	|		380.0		|			3.33			|		38.95		|
3700	|		380.0		|			2.78			|		38.95		|
3800	|		380.0		|			2.78			|		38.95		|
3900	|		380.0		|			0.00			|		39.23		|
4000	|		380.0		|			2.78			|		38.95		|	617
_______________________________________________________________________________________________________________________________________

Performance Measurement:
Turnaround Time	187.60
Waiting Time	158.99
Processing Time	28.61
Completed Jobs	126
Rejected Jobs @ 5000: 785

============================================================== Best Best Fit ==========================================================
VTU	|	Total Fragmented KBs	|	Storage Utilization (Used/Total)	|	Average Hole Size	|Rejected Jobs
1000	|		280.0		|			21.11			|		76.11		|	4
1100	|		280.0		|			12.78			|		79.47		|
1200	|		300.0		|			40.00			|		62.50		|
1300	|		300.0		|			14.44			|		76.84		|
1400	|		300.0		|			20.00			|		74.44		|
1500	|		300.0		|			9.44			|		76.50		|
1600	|		320.0		|			46.67			|		59.29		|
1700	|		320.0		|			16.67			|		76.11		|
1800	|		320.0		|			11.11			|		73.50		|
1900	|		320.0		|			8.89			|		71.43		|
2000	|		370.0		|			36.11			|		48.50		|	25
2100	|		370.0		|			24.44			|		58.50		|
2200	|		370.0		|			15.56			|		60.45		|
2300	|		370.0		|			33.33			|		55.56		|
2400	|		370.0		|			27.78			|		55.00		|
2500	|		370.0		|			46.11			|		45.29		|
2600	|		370.0		|			31.11			|		52.00		|
2700	|		370.0		|			30.00			|		53.00		|
2800	|		370.0		|			35.00			|		50.53		|
2900	|		370.0		|			18.33			|		60.00		|
3000	|		370.0		|			18.33			|		63.00		|	47
3100	|		370.0		|			20.56			|		61.00		|
3200	|		370.0		|			5.00			|		65.22		|
3300	|		370.0		|			8.33			|		65.00		|
3400	|		370.0		|			19.44			|		57.62		|
3500	|		370.0		|			29.44			|		51.50		|
3600	|		370.0		|			18.89			|		64.21		|
3700	|		370.0		|			36.67			|		51.76		|
3800	|		390.0		|			33.89			|		48.95		|
3900	|		390.0		|			24.44			|		52.38		|
4000	|		390.0		|			25.56			|		50.95		|	67
_______________________________________________________________________________________________________________________________________

Performance Measurement:
Turnaround Time	171.26
Waiting Time	141.01
Processing Time	30.25
Completed Jobs	131
Rejected Jobs @ 5000: 99

============================================================== Worst Worst Fit ========================================================
VTU	|	Total Fragmented KBs	|	Storage Utilization (Used/Total)	|	Average Hole Size	|Rejected Jobs
1000	|		260.0		|			27.22			|		52.00		|	90
1100	|		260.0		|			5.00			|		54.84		|
1200	|		340.0		|			21.67			|		47.24		|
1300	|		340.0		|			8.33			|		48.79		|
1400	|		370.0		|			17.78			|		45.48		|
1500	|		370.0		|			7.22			|		47.06		|
1600	|		390.0		|			7.22			|		45.43		|
1700	|		450.0		|			21.11			|		39.39		|
1800	|		450.0		|			9.44			|		40.81		|
1900	|		450.0		|			3.33			|		41.54		|
2000	|		450.0		|			2.78			|		41.28		|	272
2100	|		450.0		|			3.33			|		40.77		|
2200	|		450.0		|			2.78			|		40.51		|
2300	|		450.0		|			0.00			|		40.75		|
2400	|		450.0		|			2.78			|		40.00		|
2500	|		450.0		|			0.00			|		40.25		|
2600	|		450.0		|			3.33			|		39.74		|
2700	|		450.0		|			0.00			|		40.00		|
2800	|		450.0		|			0.00			|		40.00		|
2900	|		450.0		|			2.78			|		39.74		|
3000	|		450.0		|			0.00			|		40.00		|	464
3100	|		450.0		|			0.00			|		40.00		|
3200	|		450.0		|			0.00			|		40.00		|
3300	|		450.0		|			0.00			|		40.00		|
3400	|		450.0		|			0.00			|		40.00		|
3500	|		450.0		|			0.00			|		40.00		|
3600	|		450.0		|			0.00			|		40.00		|
3700	|		450.0		|			0.00			|		40.00		|
3800	|		450.0		|			0.00			|		40.00		|
3900	|		450.0		|			0.00			|		40.00		|
4000	|		450.0		|			0.00			|		40.00		|	633
_______________________________________________________________________________________________________________________________________

Performance Measurement:
Turnaround Time	135.51
Waiting Time	104.92
Processing Time	30.59
Completed Jobs	81
Rejected Jobs @ 5000: 800
bash-4.3$ exit
exit

Script done on Sun 06 Mar 2016 04:28:11 PM CST
